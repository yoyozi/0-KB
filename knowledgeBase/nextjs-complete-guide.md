---
title: "Next.js Complete Guide"
description: "Comprehensive guide to Next.js 13/14 including App Router, Server Components, routing, data fetching, API routes, metadata, caching, and deployment"
tags:
  - nextjs
  - react
  - typescript
  - server-components
  - app-router
  - full-stack
  - seo
  - ssr
date: 2024-11-03
lastUpdated: 2024-11-03
---

# Next.js Complete Guide

Complete guide to building production-ready React applications with Next.js 13/14.

## Table of Contents

- [Introduction](#introduction)
- [Installation](#installation)
- [App Router (Next.js 13+)](#app-router-nextjs-13)
- [Routing](#routing)
- [Layouts](#layouts)
- [Metadata and SEO](#metadata-and-seo)
- [Server vs Client Components](#server-vs-client-components)
- [Data Fetching](#data-fetching)
- [Dynamic Routes](#dynamic-routes)
- [API Routes](#api-routes)
- [Caching and Revalidation](#caching-and-revalidation)
- [Loading and Error States](#loading-and-error-states)
- [Images and Fonts](#images-and-fonts)
- [Deployment](#deployment)

## Introduction

Next.js is a full-stack React framework for production applications.

### Key Features

1. **Server-Side Rendering (SSR)** - Better SEO and performance
2. **File-Based Routing** - Automatic routing from file system
3. **Full-Stack Capabilities** - API routes and server actions
4. **Image Optimization** - Automatic image optimization
5. **Built-in CSS Support** - CSS Modules, Tailwind, Sass
6. **TypeScript Support** - First-class TypeScript support

### Next.js 13/14 Features

- App Directory (App Router)
- React Server Components
- Streaming and Suspense
- Server Actions
- Improved Data Fetching
- Layouts and Templates
- Metadata API
- Route Handlers

## Installation

### Create New Project

```bash
# Latest version
npx create-next-app@latest my-app

# With TypeScript
npx create-next-app@latest my-app --typescript

# Navigate to project
cd my-app

# Start development server
npm run dev
```

### Project Structure (App Router)

```
my-app/
├── app/
│   ├── layout.tsx       # Root layout
│   ├── page.tsx         # Home page
│   ├── loading.tsx      # Loading UI
│   ├── error.tsx        # Error UI
│   ├── not-found.tsx    # 404 page
│   └── api/             # API routes
├── public/              # Static files
├── components/          # React components
├── lib/                 # Utility functions
└── package.json
```

## App Router (Next.js 13+)

The App Router uses the `app/` directory for routing.

### File Conventions

| File | Purpose |
|------|---------|
| `layout.tsx` | Shared UI for a segment |
| `page.tsx` | Unique UI and makes route publicly accessible |
| `loading.tsx` | Loading UI |
| `error.tsx` | Error UI |
| `not-found.tsx` | 404 UI |
| `route.tsx` | API endpoint |
| `template.tsx` | Re-rendered layout |

## Routing

### Basic Routing

```
app/
├── page.tsx           → /
├── about/
│   └── page.tsx       → /about
├── blog/
│   ├── page.tsx       → /blog
│   └── [slug]/
│       └── page.tsx   → /blog/:slug
└── dashboard/
    ├── layout.tsx
    └── page.tsx       → /dashboard
```

### Creating Pages

```tsx
// app/page.tsx (Home page)
export default function Home() {
  return (
    <main>
      <h1>Welcome to Next.js</h1>
    </main>
  )
}
```

```tsx
// app/about/page.tsx
export default function About() {
  return (
    <div>
      <h1>About Us</h1>
      <p>This is the about page</p>
    </div>
  )
}
```

### Navigation

```tsx
import Link from 'next/link'

export default function Navigation() {
  return (
    <nav>
      <Link href="/">Home</Link>
      <Link href="/about">About</Link>
      <Link href="/blog">Blog</Link>
    </nav>
  )
}
```

### Programmatic Navigation

```tsx
'use client'

import { useRouter } from 'next/navigation'

export default function MyComponent() {
  const router = useRouter()

  const handleClick = () => {
    router.push('/dashboard')
  }

  return <button onClick={handleClick}>Go to Dashboard</button>
}
```

## Layouts

### Root Layout

```tsx
// app/layout.tsx
import './globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'My App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <header>
          <nav>{/* Navigation */}</nav>
        </header>
        <main>{children}</main>
        <footer>{/* Footer */}</footer>
      </body>
    </html>
  )
}
```

### Nested Layouts

```tsx
// app/dashboard/layout.tsx
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="dashboard">
      <aside>
        {/* Sidebar */}
      </aside>
      <section>{children}</section>
    </div>
  )
}
```

## Metadata and SEO

### Static Metadata

```tsx
// app/about/page.tsx
import { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'About Us',
  description: 'Learn more about our company',
  keywords: ['about', 'company', 'team'],
}

export default function About() {
  return <div>About Page</div>
}
```

### Dynamic Metadata

```tsx
// app/blog/[slug]/page.tsx
import { Metadata } from 'next'

type Props = {
  params: { slug: string }
}

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const post = await getPost(params.slug)

  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.image],
    },
  }
}

export default async function BlogPost({ params }: Props) {
  const post = await getPost(params.slug)
  return <article>{/* Post content */}</article>
}
```

## Server vs Client Components

### Server Components (Default)

All components in the App Router are Server Components by default.

**Advantages:**
- Faster page loads
- Smaller client bundle
- SEO friendly
- Access to backend resources
- More secure

**Limitations:**
- No hooks (useState, useEffect, etc.)
- No browser APIs
- No event handlers

```tsx
// app/components/ServerComponent.tsx
// Server Component (default)
async function getData() {
  const res = await fetch('https://api.example.com/data')
  return res.json()
}

export default async function ServerComponent() {
  const data = await getData()
  
  return (
    <div>
      <h1>{data.title}</h1>
    </div>
  )
}
```

### Client Components

Add `'use client'` directive at the top.

```tsx
// app/components/ClientComponent.tsx
'use client'

import { useState } from 'react'

export default function ClientComponent() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  )
}
```

### When to Use Client Components

- Interactive elements (buttons, forms)
- State management (useState, useReducer)
- Effects (useEffect)
- Browser APIs (localStorage, geolocation)
- Event listeners (onClick, onChange)
- Custom hooks

## Data Fetching

### Server Components (Recommended)

```tsx
// app/posts/page.tsx
async function getPosts() {
  const res = await fetch('https://api.example.com/posts')
  
  if (!res.ok) {
    throw new Error('Failed to fetch posts')
  }
  
  return res.json()
}

export default async function PostsPage() {
  const posts = await getPosts()

  return (
    <div>
      {posts.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  )
}
```

### Client-Side Fetching

```tsx
'use client'

import { useState, useEffect } from 'react'

export default function ClientPosts() {
  const [posts, setPosts] = useState([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch('https://api.example.com/posts')
      .then(res => res.json())
      .then(data => {
        setPosts(data)
        setLoading(false)
      })
  }, [])

  if (loading) return <div>Loading...</div>

  return (
    <div>
      {posts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  )
}
```

## Dynamic Routes

### Single Dynamic Segment

```tsx
// app/blog/[slug]/page.tsx
type Props = {
  params: { slug: string }
}

export default async function BlogPost({ params }: Props) {
  const post = await getPost(params.slug)

  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
    </article>
  )
}
```

### Multiple Dynamic Segments

```tsx
// app/blog/[category]/[slug]/page.tsx
type Props = {
  params: {
    category: string
    slug: string
  }
}

export default async function Post({ params }: Props) {
  const post = await getPost(params.category, params.slug)
  return <article>{/* Post content */}</article>
}
```

### Catch-All Routes

```tsx
// app/docs/[...slug]/page.tsx
type Props = {
  params: { slug: string[] }
}

export default function Docs({ params }: Props) {
  // /docs/a/b/c → params.slug = ['a', 'b', 'c']
  return <div>Docs: {params.slug.join('/')}</div>
}
```

### Generate Static Params

```tsx
// app/blog/[slug]/page.tsx
export async function generateStaticParams() {
  const posts = await getPosts()

  return posts.map((post) => ({
    slug: post.slug,
  }))
}

export default async function BlogPost({ params }: Props) {
  const post = await getPost(params.slug)
  return <article>{/* Post content */}</article>
}
```

## API Routes

### Route Handlers

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

// GET /api/posts
export async function GET() {
  const posts = await getPosts()
  return NextResponse.json(posts)
}

// POST /api/posts
export async function POST(request: Request) {
  const body = await request.json()
  const post = await createPost(body)
  return NextResponse.json(post, { status: 201 })
}
```

### Dynamic API Routes

```tsx
// app/api/posts/[id]/route.ts
import { NextResponse } from 'next/server'

type Props = {
  params: { id: string }
}

// GET /api/posts/:id
export async function GET(request: Request, { params }: Props) {
  const post = await getPost(params.id)
  
  if (!post) {
    return NextResponse.json(
      { error: 'Post not found' },
      { status: 404 }
    )
  }
  
  return NextResponse.json(post)
}

// DELETE /api/posts/:id
export async function DELETE(request: Request, { params }: Props) {
  await deletePost(params.id)
  return NextResponse.json({ success: true })
}
```

## Caching and Revalidation

### Revalidate Fetch Requests

```tsx
// Revalidate every 60 seconds
async function getPosts() {
  const res = await fetch('https://api.example.com/posts', {
    next: { revalidate: 60 }
  })
  return res.json()
}
```

### Disable Caching

```tsx
// No caching
async function getPosts() {
  const res = await fetch('https://api.example.com/posts', {
    cache: 'no-store'
  })
  return res.json()
}
```

### Route Segment Config

```tsx
// app/blog/page.tsx
export const revalidate = 60 // Revalidate every 60 seconds
export const dynamic = 'force-dynamic' // Always dynamic
export const runtime = 'edge' // Use Edge Runtime

export default async function BlogPage() {
  const posts = await getPosts()
  return <div>{/* Posts */}</div>
}
```

## Loading and Error States

### Loading UI

```tsx
// app/blog/loading.tsx
export default function Loading() {
  return (
    <div className="loading">
      <div className="spinner"></div>
      <p>Loading posts...</p>
    </div>
  )
}
```

### Error Handling

```tsx
// app/blog/error.tsx
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <p>{error.message}</p>
      <button onClick={() => reset()}>Try again</button>
    </div>
  )
}
```

### Suspense Boundaries

```tsx
import { Suspense } from 'react'

export default function Page() {
  return (
    <div>
      <h1>My Page</h1>
      <Suspense fallback={<div>Loading posts...</div>}>
        <Posts />
      </Suspense>
      <Suspense fallback={<div>Loading comments...</div>}>
        <Comments />
      </Suspense>
    </div>
  )
}
```

## Images and Fonts

### Next.js Image Component

```tsx
import Image from 'next/image'

export default function MyImage() {
  return (
    <Image
      src="/profile.jpg"
      alt="Profile"
      width={500}
      height={500}
      priority
    />
  )
}
```

### Remote Images

```tsx
// next.config.js
module.exports = {
  images: {
    domains: ['example.com'],
  },
}
```

```tsx
<Image
  src="https://example.com/image.jpg"
  alt="Remote image"
  width={500}
  height={500}
/>
```

### Google Fonts

```tsx
// app/layout.tsx
import { Inter, Poppins } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })
const poppins = Poppins({
  weight: ['400', '700'],
  subsets: ['latin'],
})

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
        {children}
      </body>
    </html>
  )
}
```

## Server Actions

Server Actions allow you to run server-side code directly from client components.

```tsx
// app/actions.ts
'use server'

export async function createPost(formData: FormData) {
  const title = formData.get('title')
  const content = formData.get('content')

  // Save to database
  await db.post.create({
    data: { title, content }
  })

  revalidatePath('/blog')
}
```

```tsx
// app/components/PostForm.tsx
'use client'

import { createPost } from '../actions'

export default function PostForm() {
  return (
    <form action={createPost}>
      <input name="title" required />
      <textarea name="content" required />
      <button type="submit">Create Post</button>
    </form>
  )
}
```

## Deployment

### Build for Production

```bash
npm run build
npm start
```

### Deploy to Vercel

```bash
# Install Vercel CLI
npm i -g vercel

# Deploy
vercel

# Deploy to production
vercel --prod
```

### Environment Variables

```env
# .env.local
DATABASE_URL=postgresql://...
API_KEY=your_api_key
NEXT_PUBLIC_API_URL=https://api.example.com
```

**Note:** Variables prefixed with `NEXT_PUBLIC_` are exposed to the browser.

## Best Practices

1. **Use Server Components by default** - Only use Client Components when necessary
2. **Fetch data at the component level** - Parallel data fetching
3. **Use Suspense boundaries** - Better loading states
4. **Optimize images** - Use Next.js Image component
5. **Implement proper error handling** - Use error.tsx files
6. **Use TypeScript** - Better type safety
7. **Leverage caching** - Use revalidation strategies
8. **Keep client bundle small** - Minimize client-side JavaScript
9. **Use Server Actions** - Simplify form submissions
10. **Test on production build** - Always test with `npm run build`

## Quick Reference

```bash
# Create new app
npx create-next-app@latest

# Development
npm run dev

# Build
npm run build

# Start production
npm start

# Lint
npm run lint
```

---

**Related Topics:**
- React Server Components
- Vercel Deployment
- Prisma ORM
- NextAuth.js
- Tailwind CSS
- TypeScript
